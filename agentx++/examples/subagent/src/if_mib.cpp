/*_############################################################################
  _## 
  _##  if_mib.cpp  
  _## 
  _##
  _##  AgentX++ 2
  _##  -------------------------------------
  _##  Copyright (C) 2000-2013 - Frank Fock
  _##  
  _##  Use of this software is subject to the license agreement you received
  _##  with this software and which can be downloaded from 
  _##  http://www.agentpp.com
  _##
  _##  This is licensed software and may not be used in a commercial
  _##  environment, except for evaluation purposes, unless a valid
  _##  license has been purchased.
  _##  
  _##########################################################################*/


#include <if_mib.h>


/**
 *  generated by AgentGen 1.5.2 for AGENT++v3.4 
 * Wed Feb 28 01:09:22 GMT+01:00 2001.
 */


//--AgentGen BEGIN=_INCLUDE
#include <agent_pp/system_group.h>
#include <snmp_pp/log.h>
#ifdef linux
#include <unistd.h>
#include <stdlib.h>
#include <ctype.h>

#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/sysctl.h>
#include <net/if.h>
#include <netinet/ip.h>
#endif

#ifdef SNMP_PP_NAMESPACE
using namespace Snmp_pp;
#endif

#ifdef AGENTPP_NAMESPACE
namespace Agentpp {
#endif

static const char *loggerModuleName = "agentx++.if_mib";
    
//--AgentGen END


/**
 *  ifNumber
 *
 */

ifNumber* ifNumber::instance = 0;

ifNumber::ifNumber():
   MibLeaf(oidIfNumber, READONLY, new SnmpInt32())
{
	// This leaf object is a singleton. In order to access it use
	// the static pointer ifNumber::instance.
	instance = this;

	//--AgentGen BEGIN=ifNumber::ifNumber
	//--AgentGen END

}

ifNumber::~ifNumber()
{

	//--AgentGen BEGIN=ifNumber::~ifNumber
	//--AgentGen END
}

void ifNumber::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifNumber::get_request
	if (ifEntry::instance) {
		ifEntry::instance->update(req);
		set_state(ifEntry::instance->size());
	}
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

long ifNumber::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifNumber::set_state(long l)
{

	//--AgentGen BEGIN=ifNumber::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}


//--AgentGen BEGIN=ifNumber
//--AgentGen END




/**
 *  ifAdminStatus
 *
 */

ifAdminStatus::ifAdminStatus(const Oidx& id):
   MibLeaf(id, READWRITE, new SnmpInt32())
{

	//--AgentGen BEGIN=ifAdminStatus::ifAdminStatus
	set_access(READONLY);
	//--AgentGen END

}

ifAdminStatus::~ifAdminStatus()
{

	//--AgentGen BEGIN=ifAdminStatus::~ifAdminStatus
	//--AgentGen END
}

MibEntryPtr ifAdminStatus::clone()
{
	MibEntryPtr other = new ifAdminStatus(oid);
	((ifAdminStatus*)other)->replace_value(value->clone());
	((ifAdminStatus*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifAdminStatus::clone
	//--AgentGen END
	return other;
}

void ifAdminStatus::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifAdminStatus::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

long ifAdminStatus::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifAdminStatus::set_state(long l)
{

	//--AgentGen BEGIN=ifAdminStatus::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}

int ifAdminStatus::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifAdminStatus::set
        long l = 0;
	vb.get_value(l);
	//	*((SnmpInt32*)value) = l;
	Vbx vbs[3];
	Oidx index(my_row->get_index());
    if (index.len() <= 0) {
        return SNMP_ERROR_GENERAL_VB_ERR;
    }
	Oidx ind("1.3.6.1.2.1.2.2.1.1");
	ind += index;
	vbs[0].set_oid(ind);
	Oidx adminStatus(oidIfAdminStatus);
	adminStatus += index;
	Oidx operStatus(oidIfOperStatus);
	operStatus += index;

	vbs[0].set_oid(ind);
	vbs[0].set_value(SnmpUInt32(index[0]));
	vbs[1].set_oid(adminStatus);
	int state = 0;
	my_row->get_nth(7)->get_value(state);
	vbs[1].set_value(SnmpInt32(state));
	vbs[2].set_oid(operStatus);
	vbs[2].set_value(SnmpInt32(get_state()));	
	switch(l) {
	case 1: { 
	  linkUp no(((AgentXSharedTable*)my_table)->get_subagent_mib());
	  no.generate(vbs, 3, "");
	  break;	
	}
	default: {
	  linkDown no(((AgentXSharedTable*)my_table)->get_subagent_mib());
	  no.generate(vbs, 3, "");
	  break;
	}
	}
	my_row->get_nth(7)->replace_value(new SnmpInt32(l));
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifAdminStatus::value_ok(const Vbx& vb)
{
	long v;
	vb.get_value(v);
	if ((v != 1)
	     && (v != 2) && (v != 3)
	    ) return FALSE;

	//--AgentGen BEGIN=ifAdminStatus::value_ok
	//--AgentGen END
	return TRUE;
}

int ifAdminStatus::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = MibLeaf::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifAdminStatus::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifAdminStatus
//--AgentGen END




/**
 *  ifLinkUpDownTrapEnable
 *
 */

ifLinkUpDownTrapEnable::ifLinkUpDownTrapEnable(const Oidx& id):
   MibLeaf(id, READWRITE, new SnmpInt32())
{

	//--AgentGen BEGIN=ifLinkUpDownTrapEnable::ifLinkUpDownTrapEnable
	//--AgentGen END

}

ifLinkUpDownTrapEnable::~ifLinkUpDownTrapEnable()
{

	//--AgentGen BEGIN=ifLinkUpDownTrapEnable::~ifLinkUpDownTrapEnable
	//--AgentGen END
}

MibEntryPtr ifLinkUpDownTrapEnable::clone()
{
	MibEntryPtr other = new ifLinkUpDownTrapEnable(oid);
	((ifLinkUpDownTrapEnable*)other)->replace_value(value->clone());
	((ifLinkUpDownTrapEnable*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifLinkUpDownTrapEnable::clone
	//--AgentGen END
	return other;
}

void ifLinkUpDownTrapEnable::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifLinkUpDownTrapEnable::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

long ifLinkUpDownTrapEnable::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifLinkUpDownTrapEnable::set_state(long l)
{

	//--AgentGen BEGIN=ifLinkUpDownTrapEnable::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}

int ifLinkUpDownTrapEnable::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifLinkUpDownTrapEnable::set
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifLinkUpDownTrapEnable::value_ok(const Vbx& vb)
{
	long v;
	vb.get_value(v);
	if ((v != 1)
	     && (v != 2)) return FALSE;

	//--AgentGen BEGIN=ifLinkUpDownTrapEnable::value_ok
	//--AgentGen END
	return TRUE;
}

int ifLinkUpDownTrapEnable::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = MibLeaf::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifLinkUpDownTrapEnable::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifLinkUpDownTrapEnable
//--AgentGen END




/**
 *  ifPromiscuousMode
 *
 */

ifPromiscuousMode::ifPromiscuousMode(const Oidx& id):
   MibLeaf(id, READWRITE, new SnmpInt32())
{

	//--AgentGen BEGIN=ifPromiscuousMode::ifPromiscuousMode
	//--AgentGen END

}

ifPromiscuousMode::~ifPromiscuousMode()
{

	//--AgentGen BEGIN=ifPromiscuousMode::~ifPromiscuousMode
	//--AgentGen END
}

MibEntryPtr ifPromiscuousMode::clone()
{
	MibEntryPtr other = new ifPromiscuousMode(oid);
	((ifPromiscuousMode*)other)->replace_value(value->clone());
	((ifPromiscuousMode*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifPromiscuousMode::clone
	//--AgentGen END
	return other;
}

void ifPromiscuousMode::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifPromiscuousMode::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

long ifPromiscuousMode::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifPromiscuousMode::set_state(long l)
{

	//--AgentGen BEGIN=ifPromiscuousMode::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}

int ifPromiscuousMode::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifPromiscuousMode::set
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifPromiscuousMode::value_ok(const Vbx& vb)
{
	long v;
	vb.get_value(v);
	if ((v != 1)
	     && (v != 2)) return FALSE;

	//--AgentGen BEGIN=ifPromiscuousMode::value_ok
	//--AgentGen END
	return TRUE;
}

int ifPromiscuousMode::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = MibLeaf::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifPromiscuousMode::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifPromiscuousMode
//--AgentGen END




/**
 *  ifAlias
 *
 */

ifAlias::ifAlias(const Oidx& id):
   SnmpDisplayString(id, READWRITE, new OctetStr())
{

	//--AgentGen BEGIN=ifAlias::ifAlias
	//--AgentGen END

}

ifAlias::~ifAlias()
{

	//--AgentGen BEGIN=ifAlias::~ifAlias
	//--AgentGen END
}

MibEntryPtr ifAlias::clone()
{
	MibEntryPtr other = new ifAlias(oid);
	((ifAlias*)other)->replace_value(value->clone());
	((ifAlias*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifAlias::clone
	//--AgentGen END
	return other;
}

void ifAlias::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifAlias::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

int ifAlias::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifAlias::set
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifAlias::value_ok(const Vbx& vb)
{

	//--AgentGen BEGIN=ifAlias::value_ok
	//--AgentGen END
	return TRUE;
}

int ifAlias::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = SnmpDisplayString::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;
	Vb vb(req->get_value(ind));
	OctetStr v;
	vb.get_value(v);
	if (!(((v.len() >= 0) && (v.len() <= 255))))
		 return SNMP_ERROR_WRONG_LENGTH;

	//--AgentGen BEGIN=ifAlias::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifAlias
//--AgentGen END




/**
 *  ifStackStatus
 *
 */

ifStackStatus::ifStackStatus(const Oidx& id):
   snmpRowStatus(id, READCREATE)

{

	//--AgentGen BEGIN=ifStackStatus::ifStackStatus
	//--AgentGen END

}

ifStackStatus::~ifStackStatus()
{

	//--AgentGen BEGIN=ifStackStatus::~ifStackStatus
	//--AgentGen END
}

MibEntryPtr ifStackStatus::clone()
{
	MibEntryPtr other = new ifStackStatus(oid);
	((ifStackStatus*)other)->replace_value(value->clone());
	((ifStackStatus*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifStackStatus::clone
	//--AgentGen END
	return other;
}

long ifStackStatus::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifStackStatus::set_state(long l)
{

	//--AgentGen BEGIN=ifStackStatus::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}

int ifStackStatus::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifStackStatus::set
	//--AgentGen END
	return snmpRowStatus::set(vb);
}

int ifStackStatus::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = snmpRowStatus::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifStackStatus::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifStackStatus
//--AgentGen END




/**
 *  ifTestId
 *
 */

ifTestId::ifTestId(const Oidx& id):
   MibLeaf(id, READWRITE, new SnmpInt32())
{

	//--AgentGen BEGIN=ifTestId::ifTestId
	//--AgentGen END

}

ifTestId::~ifTestId()
{

	//--AgentGen BEGIN=ifTestId::~ifTestId
	//--AgentGen END
}

MibEntryPtr ifTestId::clone()
{
	MibEntryPtr other = new ifTestId(oid);
	((ifTestId*)other)->replace_value(value->clone());
	((ifTestId*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifTestId::clone
	//--AgentGen END
	return other;
}

void ifTestId::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifTestId::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

long ifTestId::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifTestId::set_state(long l)
{

	//--AgentGen BEGIN=ifTestId::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}

int ifTestId::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifTestId::set
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifTestId::value_ok(const Vbx& vb)
{
	long v;
	vb.get_value(v);
	if (!(((v >= 0) && (v <= 2147483647))))
		 return FALSE;

	//--AgentGen BEGIN=ifTestId::value_ok
	//--AgentGen END
	return TRUE;
}

int ifTestId::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = MibLeaf::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifTestId::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifTestId
//--AgentGen END




/**
 *  ifTestStatus
 *
 */

ifTestStatus::ifTestStatus(const Oidx& id):
   MibLeaf(id, READWRITE, new SnmpInt32())
{

	//--AgentGen BEGIN=ifTestStatus::ifTestStatus
	//--AgentGen END

}

ifTestStatus::~ifTestStatus()
{

	//--AgentGen BEGIN=ifTestStatus::~ifTestStatus
	//--AgentGen END
}

MibEntryPtr ifTestStatus::clone()
{
	MibEntryPtr other = new ifTestStatus(oid);
	((ifTestStatus*)other)->replace_value(value->clone());
	((ifTestStatus*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifTestStatus::clone
	//--AgentGen END
	return other;
}

void ifTestStatus::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifTestStatus::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

long ifTestStatus::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifTestStatus::set_state(long l)
{

	//--AgentGen BEGIN=ifTestStatus::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}

int ifTestStatus::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifTestStatus::set
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifTestStatus::value_ok(const Vbx& vb)
{
	long v;
	vb.get_value(v);
	if ((v != 1)
	     && (v != 2)) return FALSE;

	//--AgentGen BEGIN=ifTestStatus::value_ok
	//--AgentGen END
	return TRUE;
}

int ifTestStatus::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = MibLeaf::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifTestStatus::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifTestStatus
//--AgentGen END




/**
 *  ifTestType
 *
 */

ifTestType::ifTestType(const Oidx& id):
   MibLeaf(id, READWRITE, new Oid())
{

	//--AgentGen BEGIN=ifTestType::ifTestType
	//--AgentGen END

}

ifTestType::~ifTestType()
{

	//--AgentGen BEGIN=ifTestType::~ifTestType
	//--AgentGen END
}

MibEntryPtr ifTestType::clone()
{
	MibEntryPtr other = new ifTestType(oid);
	((ifTestType*)other)->replace_value(value->clone());
	((ifTestType*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifTestType::clone
	//--AgentGen END
	return other;
}

void ifTestType::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifTestType::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

int ifTestType::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifTestType::set
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifTestType::value_ok(const Vbx& vb)
{

	//--AgentGen BEGIN=ifTestType::value_ok
	//--AgentGen END
	return TRUE;
}

int ifTestType::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = MibLeaf::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifTestType::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifTestType
//--AgentGen END




/**
 *  ifTestOwner
 *
 */

ifTestOwner::ifTestOwner(const Oidx& id):
   MibLeaf(id, READWRITE, new OctetStr())
{

	//--AgentGen BEGIN=ifTestOwner::ifTestOwner
	//--AgentGen END

}

ifTestOwner::~ifTestOwner()
{

	//--AgentGen BEGIN=ifTestOwner::~ifTestOwner
	//--AgentGen END
}

MibEntryPtr ifTestOwner::clone()
{
	MibEntryPtr other = new ifTestOwner(oid);
	((ifTestOwner*)other)->replace_value(value->clone());
	((ifTestOwner*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifTestOwner::clone
	//--AgentGen END
	return other;
}

void ifTestOwner::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifTestOwner::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

int ifTestOwner::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifTestOwner::set
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifTestOwner::value_ok(const Vbx& vb)
{

	//--AgentGen BEGIN=ifTestOwner::value_ok
	//--AgentGen END
	return TRUE;
}

int ifTestOwner::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = MibLeaf::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;
	Vb vb(req->get_value(ind));
	OctetStr v;
	vb.get_value(v);
	if (!(((v.len() >= 0) && (v.len() <= 255))))
		 return SNMP_ERROR_WRONG_LENGTH;

	//--AgentGen BEGIN=ifTestOwner::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifTestOwner
//--AgentGen END




/**
 *  ifRcvAddressStatus
 *
 */

ifRcvAddressStatus::ifRcvAddressStatus(const Oidx& id):
   snmpRowStatus(id, READCREATE)

{

	//--AgentGen BEGIN=ifRcvAddressStatus::ifRcvAddressStatus
	//--AgentGen END

}

ifRcvAddressStatus::~ifRcvAddressStatus()
{

	//--AgentGen BEGIN=ifRcvAddressStatus::~ifRcvAddressStatus
	//--AgentGen END
}

MibEntryPtr ifRcvAddressStatus::clone()
{
	MibEntryPtr other = new ifRcvAddressStatus(oid);
	((ifRcvAddressStatus*)other)->replace_value(value->clone());
	((ifRcvAddressStatus*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifRcvAddressStatus::clone
	//--AgentGen END
	return other;
}

long ifRcvAddressStatus::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifRcvAddressStatus::set_state(long l)
{

	//--AgentGen BEGIN=ifRcvAddressStatus::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}

int ifRcvAddressStatus::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifRcvAddressStatus::set
	//--AgentGen END
	return snmpRowStatus::set(vb);
}

int ifRcvAddressStatus::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = snmpRowStatus::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifRcvAddressStatus::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifRcvAddressStatus
//--AgentGen END




/**
 *  ifRcvAddressType
 *
 */

ifRcvAddressType::ifRcvAddressType(const Oidx& id):
   MibLeaf(id, READCREATE, new SnmpInt32(2), VMODE_DEFAULT)
{

	//--AgentGen BEGIN=ifRcvAddressType::ifRcvAddressType
	//--AgentGen END

}

ifRcvAddressType::~ifRcvAddressType()
{

	//--AgentGen BEGIN=ifRcvAddressType::~ifRcvAddressType
	//--AgentGen END
}

MibEntryPtr ifRcvAddressType::clone()
{
	MibEntryPtr other = new ifRcvAddressType(oid);
	((ifRcvAddressType*)other)->replace_value(value->clone());
	((ifRcvAddressType*)other)->set_reference_to_table(my_table);

	//--AgentGen BEGIN=ifRcvAddressType::clone
	//--AgentGen END
	return other;
}

void ifRcvAddressType::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifRcvAddressType::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}

long ifRcvAddressType::get_state()
{
	return (long)*((SnmpInt32*)value);
}

void ifRcvAddressType::set_state(long l)
{

	//--AgentGen BEGIN=ifRcvAddressType::set_state
	//--AgentGen END
	*((SnmpInt32*)value) = l;
}

int ifRcvAddressType::set(const Vbx& vb)
{

	//--AgentGen BEGIN=ifRcvAddressType::set
	//--AgentGen END
	return MibLeaf::set(vb);
}

bool ifRcvAddressType::value_ok(const Vbx& vb)
{
	long v;
	vb.get_value(v);
	if ((v != 1)
	     && (v != 2) && (v != 3)
	    ) return FALSE;

	//--AgentGen BEGIN=ifRcvAddressType::value_ok
	//--AgentGen END
	return TRUE;
}

int ifRcvAddressType::prepare_set_request(Request* req, int& ind)
{
	int status;
	if ((status = MibLeaf::prepare_set_request(req, ind)) !=
	    SNMP_ERROR_SUCCESS) return status;

	//--AgentGen BEGIN=ifRcvAddressType::prepare_set_request
	//--AgentGen END
	return SNMP_ERROR_SUCCESS;
}


//--AgentGen BEGIN=ifRcvAddressType
//--AgentGen END




/**
 *  ifTableLastChange
 *
 */

ifTableLastChange* ifTableLastChange::instance = 0;

ifTableLastChange::ifTableLastChange():
   MibLeaf(oidIfTableLastChange, READONLY, new TimeTicks())
{
	// This leaf object is a singleton. In order to access it use
	// the static pointer ifTableLastChange::instance.
	instance = this;

	//--AgentGen BEGIN=ifTableLastChange::ifTableLastChange
	//--AgentGen END

}

ifTableLastChange::~ifTableLastChange()
{

	//--AgentGen BEGIN=ifTableLastChange::~ifTableLastChange
	//--AgentGen END
}

void ifTableLastChange::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifTableLastChange::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=ifTableLastChange
//--AgentGen END




/**
 *  ifStackLastChange
 *
 */

ifStackLastChange* ifStackLastChange::instance = 0;

ifStackLastChange::ifStackLastChange():
   MibLeaf(oidIfStackLastChange, READONLY, new TimeTicks())
{
	// This leaf object is a singleton. In order to access it use
	// the static pointer ifStackLastChange::instance.
	instance = this;

	//--AgentGen BEGIN=ifStackLastChange::ifStackLastChange
	//--AgentGen END

}

ifStackLastChange::~ifStackLastChange()
{

	//--AgentGen BEGIN=ifStackLastChange::~ifStackLastChange
	//--AgentGen END
}

void ifStackLastChange::get_request(Request* req, int ind)
{

	//--AgentGen BEGIN=ifStackLastChange::get_request
	//--AgentGen END
	MibLeaf::get_request(req, ind);
}


//--AgentGen BEGIN=ifStackLastChange
//--AgentGen END




/**
 *  linkDown
 *
 */

linkDown::linkDown(SubAgentXMib* mib)
{
	my_mib = mib;

	//--AgentGen BEGIN=linkDown::linkDown
	backReference = mib;
	//--AgentGen END
}

linkDown::~linkDown()
{

	//--AgentGen BEGIN=linkDown::~linkDown
	//--AgentGen END
}

void linkDown::generate(Vbx* vbs, int sz, const OctetStr& context)
{

	//--AgentGen BEGIN=linkDown::generate
	//--AgentGen END
	if (sz < 3) {
		LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
		LOG("linkDown: too few var binds (given) (expected)");
		LOG(sz);
		LOG(3);
		LOG_END;
		return;
	}
	if (!(vbs[0].get_oid().in_subtree_of("1.3.6.1.2.1.2.2.1.1"))) {
		LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
		LOG("linkDown: wrong var bind (no.) (given) (expected)");
		LOG(1l);
		LOG(vbs[0].get_printable_oid());
		LOG("1.3.6.1.2.1.2.2.1.1");
		LOG_END;
		return;
	}
	if (!(vbs[1].get_oid().in_subtree_of("1.3.6.1.2.1.2.2.1.7"))) {
		LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
		LOG("linkDown: wrong var bind (no.) (given) (expected)");
		LOG(2l);
		LOG(vbs[1].get_printable_oid());
		LOG("1.3.6.1.2.1.2.2.1.7");
		LOG_END;
		return;
	}
	if (!(vbs[2].get_oid().in_subtree_of("1.3.6.1.2.1.2.2.1.8"))) {
		LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
		LOG("linkDown: wrong var bind (no.) (given) (expected)");
		LOG(3l);
		LOG(vbs[2].get_printable_oid());
		LOG("1.3.6.1.2.1.2.2.1.8");
		LOG_END;
		return;
	}
	my_mib->notify(context, oidLinkDown, vbs, sz);
}


//--AgentGen BEGIN=linkDown
//--AgentGen END


/**
 *  linkUp
 *
 */

linkUp::linkUp(SubAgentXMib* mib)
{
	my_mib = mib;

	//--AgentGen BEGIN=linkUp::linkUp
	backReference = mib;
	//--AgentGen END
}

linkUp::~linkUp()
{

	//--AgentGen BEGIN=linkUp::~linkUp
	//--AgentGen END
}

void linkUp::generate(Vbx* vbs, int sz, const OctetStr& context)
{

	//--AgentGen BEGIN=linkUp::generate
	//--AgentGen END
	if (sz < 3) {
		LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
		LOG("linkUp: too few var binds (given) (expected)");
		LOG(sz);
		LOG(3);
		LOG_END;
		return;
	}
	if (!(vbs[0].get_oid().in_subtree_of("1.3.6.1.2.1.2.2.1.1"))) {
		LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
		LOG("linkUp: wrong var bind (no.) (given) (expected)");
		LOG(1l);
		LOG(vbs[0].get_printable_oid());
		LOG("1.3.6.1.2.1.2.2.1.1");
		LOG_END;
		return;
	}
	if (!(vbs[1].get_oid().in_subtree_of("1.3.6.1.2.1.2.2.1.7"))) {
		LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
		LOG("linkUp: wrong var bind (no.) (given) (expected)");
		LOG(2l);
		LOG(vbs[1].get_printable_oid());
		LOG("1.3.6.1.2.1.2.2.1.7");
		LOG_END;
		return;
	}
	if (!(vbs[2].get_oid().in_subtree_of("1.3.6.1.2.1.2.2.1.8"))) {
		LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
		LOG("linkUp: wrong var bind (no.) (given) (expected)");
		LOG(3l);
		LOG(vbs[2].get_printable_oid());
		LOG("1.3.6.1.2.1.2.2.1.8");
		LOG_END;
		return;
	}
	my_mib->notify(context, oidLinkUp, vbs, sz);
}


//--AgentGen BEGIN=linkUp
//--AgentGen END


/**
 *  ifEntry
 *
 */

ifEntry* ifEntry::instance = 0;

const index_info indIfEntry[1] = {
	{ sNMP_SYNTAX_INT, FALSE, 1, 1 } };

const Oidx indOidsIfEntry[1] = {
	"1.3.6.1.2.1.2.2.1.1"
};

ifEntry::ifEntry(const OctetStr& context, SubAgentXMib* mib):
   AgentXSharedTable(oidIfEntry, indIfEntry, 1, indOidsIfEntry, mib, context)
{
	// This table object is a singleton. In order to access it use
	// the static pointer ifEntry::instance.
	instance = this;

	add_col(new MibLeaf(colIfIndex, READONLY, new SnmpInt32()));
	add_col(new SnmpDisplayString(colIfDescr, READONLY, new OctetStr()));
	add_col(new MibLeaf(colIfType, READONLY, new SnmpInt32()));
	add_col(new MibLeaf(colIfMtu, READONLY, new SnmpInt32()));
	add_col(new MibLeaf(colIfSpeed, READONLY, new Gauge32()));
	add_col(new MibLeaf(colIfPhysAddress, READONLY, new OctetStr()));
	add_col(new ifAdminStatus(colIfAdminStatus));
	add_col(new MibLeaf(colIfOperStatus, READONLY, new SnmpInt32()));
	add_col(new MibLeaf(colIfLastChange, READONLY, new TimeTicks()));
	add_col(new MibLeaf(colIfInOctets, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfInUcastPkts, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfInNUcastPkts, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfInDiscards, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfInErrors, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfInUnknownProtos, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfOutOctets, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfOutUcastPkts, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfOutNUcastPkts, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfOutDiscards, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfOutErrors, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfOutQLen, READONLY, new Gauge32()));
	add_col(new MibLeaf(colIfSpecific, READONLY, new Oid()));

	//--AgentGen BEGIN=ifEntry::ifEntry
#ifdef linux
	lastUpdated = 0;
	init_if_speeds();
#endif
	//--AgentGen END
}

ifEntry::~ifEntry()
{

	//--AgentGen BEGIN=ifEntry::~ifEntry
	//--AgentGen END
}

void ifEntry::update(Request* req)
{
	// This table needs to be updated.

	//--AgentGen BEGIN=ifEntry::update
#ifdef linux
	if (sysUpTime::get_currentTime() - lastUpdated > 5) {
		do_update();
		lastUpdated = sysUpTime::get_currentTime();
	}
#endif
	//--AgentGen END
}


//--AgentGen BEGIN=ifEntry
/**
 * Overwrite init_row if you use index_allocation and
 * persistent storage to avoid allocating the same
 * index again after a restart of the agent.
 */
MibTableRow* ifEntry::init_row(const Oidx& ind, Vbx* vbs) 
{
	MibTableRow* row = new MibTableRow(generator);
	newRows.add(row);
	any_index();
	for (int i=0; i<row->size(); i++) {	  
		row->get_nth(i)->set_value(vbs[i]);
	}
	return row;
}


#ifdef linux
const char *scan_line_2_2="%lu %lu %lu %*lu %*lu %*lu %*lu %*lu %lu %lu %lu %*lu %*lu %lu";
const char *scan_line_2_0="%lu %lu %*lu %*lu %*lu %lu %lu %*lu %*lu %lu";

void ifEntry::do_update() 
{
    // The following is derived from NET-SNMP 4.2
    FILE *in;
    char line [256], *cp1, *cp2, *ifname;
    SnmpSyntax* if_entry[23];
    struct ifreq ifrq;
    int  use_2_2_scan_line;
    int  fd;


    if (! (in = fopen ("/proc/net/dev", "r"))) {
	LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
	LOG("IF-MIB: cannot open /proc/net/dev ...");
	LOG_END;
	return;
    }

    // clear queue for new rows
    newRows.clearAll();

	/*
	 *  There are two formats for interface statistics output,
	 *  corresponding to the 2.0 and 2.2 kernels.
	 *  They can be distinguished by the format of the header
	 *   (i.e. the first two lines) - the 2.2 format having
	 *   a number of additional values reported.
	 *
	 *  It might be possible to analyse the fields to determine
	 *    precisely which fields are needed, but frankly, it's
	 *    not really worth it.  This format changes so infrequently
	 *    that it's reasonable to hardwire the appropriate scan line
	 *    for particular kernels.
	 */
    fgets(line, sizeof(line), in);		/* skip the first line */
    fgets(line, sizeof(line), in);		/* this has the field names */
    if (strstr(line, "compressed")) {
	use_2_2_scan_line = TRUE;
	LOG_BEGIN(loggerModuleName, INFO_LOG | 2);
	LOG("IF-MIB: using linux 2.2 kernel /proc/net/dev");
	LOG_END;
    } 
    else {
	use_2_2_scan_line = FALSE;
	LOG_BEGIN(loggerModuleName, INFO_LOG | 2);
	LOG("IF-MIB: using linux 2.0 kernel /proc/net/dev");
	LOG_END;
    }
 
	/*
	 * We need a network socket to perform ioctls on,
	 *   so let's open it now.
	 */
    if ((fd = socket (AF_INET, SOCK_DGRAM, 0)) < 0) {
	LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
	LOG("IF-MIB: socket open failure");
	LOG_END;
	fclose(in);
    }
 
		/*
		 *  Read in the various interface statistics lines,
		 *    and create 'IfList' entries for each one,
		 *    linking them into a list.
		 */
    for (int i=0; i<23; i++) {
	if_entry[i] = 0;
    }
    int n = 0;
    while (fgets (line, sizeof(line), in)) {

		/*
		 * Extract the interface name
		 *   (skipping leading blanks)
		 */
	cp1 = line;
	while (isspace( *cp1 ))
	    cp1++;
	cp2 = strrchr( cp1, ':' );
	*cp2 = '\0';

	if_entry[atoi(colIfDescr)] = new OctetStr(cp1);
	ifname = strdup(cp1);
	
		/*
		 * Extract the appropriate statistics
		 * Note that the 2.0 kernel doesn't supply octet counts
		 */
	cp2++;
	u_int if_ibytes, if_ipackets, if_ierrors,
	      if_obytes, if_opackets, if_oerrors, if_collisions;
	if ( use_2_2_scan_line ) {
	    sscanf( cp2, scan_line_2_2,
		    &if_ibytes, &if_ipackets, &if_ierrors,
		    &if_obytes, &if_opackets, &if_oerrors,
		    &if_collisions);
	}
	else {
	    sscanf( cp2, scan_line_2_0,
		    &if_ipackets, &if_ierrors,
		    &if_opackets, &if_oerrors,
		    &if_collisions);
	    if_ibytes = if_obytes = 0;
	}

	if_entry[atoi(colIfInOctets)] = new Counter32(if_ibytes);
	if_entry[atoi(colIfOutOctets)] = new Counter32(if_obytes);
	if_entry[atoi(colIfInUcastPkts)] = new Counter32(if_ipackets);
	if_entry[atoi(colIfOutUcastPkts)] = new Counter32(if_opackets);
	if_entry[atoi(colIfInErrors)] = new Counter32(if_ierrors);
	if_entry[atoi(colIfOutErrors)] = new Counter32(if_oerrors);

		/*
		 * Split the name into type and unit number
		 */

	cp2 = &(cp1[ strlen( cp1 ) -1 ]);
	for ( cp2 = cp1 ; cp2 ; cp2++ )
	    if ( isdigit( *cp2 ))
		break;

	if ( cp2 )
	while ( isdigit( *cp2 )) {
	   cp2--;
	   if (cp2 == cp1 )
		break;
	}
				/* XXX - do we actually need this ? */
	if ( cp2 ) {
	  //if_entry[colIfIndex] = new SnmpInt32(atoi(cp2));
	    *cp2 = '\0';
	}


		/*
		 *  Fill in the rest of the ifnet & ifaddr structures
		 *   using suitable ioctl calls
		 */
	
	strcpy (ifrq.ifr_name, ifname);
	short if_flags = ioctl (fd, SIOCGIFFLAGS, &ifrq) < 0 
				? 0 : ifrq.ifr_flags;
	if_entry[atoi(colIfAdminStatus)] = 
	  new SnmpInt32((if_flags & IFF_RUNNING) ? 1 : 2);
	if_entry[atoi(colIfOperStatus)] =
	  new SnmpInt32((if_flags & IFF_UP) ? 1 : 2);
	
	strcpy (ifrq.ifr_name, ifname);
	if (ioctl(fd, SIOCGIFHWADDR, &ifrq) == 0) {
	  if_entry[atoi(colIfPhysAddress)] = 
	    new OctetStr((unsigned char*)ifrq.ifr_hwaddr.sa_data, 6);

#ifdef ARPHRD_LOOPBACK
	  switch (ifrq.ifr_hwaddr.sa_family) {
	  case ARPHRD_TUNNEL:
	  case ARPHRD_TUNNEL6:
	  case ARPHRD_IPGRE:
	  case ARPHRD_SIT:
	      if_entry[atoi(colIfType)] = 
		new SnmpInt32(131); break; /* tunnel */
	  case ARPHRD_SLIP:
	  case ARPHRD_CSLIP:
	  case ARPHRD_SLIP6:
	  case ARPHRD_CSLIP6:
	      if_entry[atoi(colIfType)] = new SnmpInt32(28); break; /* slip */
	  case ARPHRD_PPP:
	      if_entry[atoi(colIfType)] = new SnmpInt32(23); break; /* ppp */
	  case ARPHRD_LOOPBACK:
	      if_entry[atoi(colIfType)] = new SnmpInt32(24); break; /* softwareLoopback */
          /* XXX: more if_arp.h:ARPHDR_xxx to IANAifType mappings... */
	  }
#endif
	}
	/*	    
	strcpy (ifrq.ifr_name, ifname);
	if_entry[atoi(colIfMetric)] = 
	  new SnmpInt32((ioctl (fd, SIOCGIFMETRIC, &ifrq) < 0
			 ? 0 : ifrq.ifr_metric);
	*/  
#ifdef SIOCGIFMTU
	strcpy (ifrq.ifr_name, ifname);
	if_entry[atoi(colIfMtu)] = 
	  new SnmpInt32((ioctl (fd, SIOCGIFMTU, &ifrq) < 0) 
	                ? 0 : ifrq.ifr_mtu);
#else
	if_entry[atoi(colIfMtu)] = new SnmpInt32(0);
#endif

	
	int if_type = 0;
	if_type  = if_type_from_name(ifname);
	if_entry[atoi(colIfSpeed)] = 
	  new Gauge32(if_speed_from_type(if_type));
	if_entry[atoi(colIfType)] = new SnmpInt32(if_type);

		/*
		 * Add this to the table
		 */
	MibTableRow* r = new MibTableRow(generator);
	for (int i=1; i<23; i++) {
		if (if_entry[i]) {
			r->get_nth(i-1)->replace_value(if_entry[i]);
			if_entry[i] = 0;
		}
	}
	
	if (n<size()) { // update
		MibTableRow* upd = content.getNth(n);
		r->set_index(upd->get_index());
		*upd = *r;
		delete r;
	}
	else {
		// request index at master -> row added above will then
		// registered when index_allocated is called back
		newRows.add(r);
		any_index();
	}
	n++;
	delete ifname;
    }	/* while fgets() */

    // remove obsolete interfaces
    if (n<content.size()) {
	n = content.size()-n;
	for (int i=0; (i<n); i++) {
	  MibTableRow* r = content.last();
	  if (r)
	    delete content.remove(r);
	}
    }
    fclose( in );
}

void ifEntry::index_allocated(const Oidx& ind, int, int, Vbx*, u_int)
{
	MibTableRow* n = newRows.removeFirst();
	if (!n) {
		// index reallocated -> reregister it
		add_row(ind);
		return;
	}
	MibTableRow* r = add_row(ind);
	n->set_index(ind);
	n->get_nth(0)->replace_value(new SnmpInt32(ind[0]));
	*r = *n;
	delete n;
}


typedef struct _match_if {
	int mi_type;
	const char *mi_name;
} match_if;

static match_if lmatch_if[] = {
	{ 24, "lo" },		/* loopback */
	{  6, "eth" },		/* ethernet */
	{  6, "le" },		/* Lance ethernet */
	{  6, "qe" },		/* Quad ethernet */
	{  6, "hme" },
	{  9, "tr" },		/* Token Ring */
	{ 23, "ppp" },		/* Point-to-Point */
	{ 28, "sl" },
	{ 37, "lane" },		/* LAN Emulation (ATM) */
	{ 37, "fa" },		/* Fore ATM */
	{ 37, "qa" },		/* Fore? ATM */
	{ 62, "qfe" },		/* Quad Fast ethernet */

	{  0, 0 }		/* end of list */
};

int ifEntry::if_type_from_name(const char *name)
{
    int len;
    match_if *pm;

    for ( pm = lmatch_if ; pm->mi_name!= NULL ; pm++ ) {
	len = strlen( pm->mi_name );
	if ( !strncmp( name, pm->mi_name, len ))
	    return (pm->mi_type);
    }
    return( 1 );	/* 'other' */
}


void ifEntry::init_if_speeds()
{
    int i;

    for ( i = 0 ; i < MAX_IF_TYPES ; i++ )
	if_speeds[i] = 0;

#define MBIT 1000000

    if_speeds[  6 ] =  10 * MBIT;		/* traditional ethernet */
    if_speeds[  9 ] =   4 * MBIT;		/* Token Ring */
    if_speeds[ 37 ] = 155 * MBIT;		/* ATM */
    if_speeds[ 62 ] = 100 * MBIT;		/* fast ethernet */

			/* XXXX - Fill in the rest */
}

int ifEntry::if_speed_from_type( int type )
{
    if (( type < MAX_IF_TYPES ) && ( type >= 0 ))
	return if_speeds[ type ];
    else
	return 0;
}

int ifEntry::if_speeds[ MAX_IF_TYPES ];


#endif
//--AgentGen END




/**
 *  ifXEntry
 *
 */

ifXEntry* ifXEntry::instance = 0;

const index_info indIfXEntry[1] = {
	{ sNMP_SYNTAX_INT, FALSE, 1, 1 } };

const Oidx indOidsIfXEntry[1] = {
	"1.3.6.1.2.1.2.2.1.1"
};

ifXEntry::ifXEntry(const OctetStr& context, SubAgentXMib* mib):
   AgentXSharedTable(oidIfXEntry, indIfXEntry, 1, indOidsIfXEntry, mib, context)
{
	// This table object is a singleton. In order to access it use
	// the static pointer ifXEntry::instance.
	instance = this;

	add_col(new SnmpDisplayString(colIfName, READONLY, new OctetStr()));
	add_col(new MibLeaf(colIfInMulticastPkts, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfInBroadcastPkts, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfOutMulticastPkts, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfOutBroadcastPkts, READONLY, new Counter32()));
	add_col(new MibLeaf(colIfHCInOctets, READONLY, new Counter64()));
	add_col(new MibLeaf(colIfHCInUcastPkts, READONLY, new Counter64()));
	add_col(new MibLeaf(colIfHCInMulticastPkts, READONLY, new Counter64()));
	add_col(new MibLeaf(colIfHCInBroadcastPkts, READONLY, new Counter64()));
	add_col(new MibLeaf(colIfHCOutOctets, READONLY, new Counter64()));
	add_col(new MibLeaf(colIfHCOutUcastPkts, READONLY, new Counter64()));
	add_col(new MibLeaf(colIfHCOutMulticastPkts, READONLY, new Counter64()));
	add_col(new MibLeaf(colIfHCOutBroadcastPkts, READONLY, new Counter64()));
	add_col(new ifLinkUpDownTrapEnable(colIfLinkUpDownTrapEnable));
	add_col(new MibLeaf(colIfHighSpeed, READONLY, new Gauge32()));
	add_col(new ifPromiscuousMode(colIfPromiscuousMode));
	add_col(new MibLeaf(colIfConnectorPresent, READONLY, new SnmpInt32()));
	add_col(new ifAlias(colIfAlias));
	add_col(new MibLeaf(colIfCounterDiscontinuityTime, READONLY, new TimeTicks()));

	//--AgentGen BEGIN=ifXEntry::ifXEntry
	//--AgentGen END
}

ifXEntry::~ifXEntry()
{

	//--AgentGen BEGIN=ifXEntry::~ifXEntry
	//--AgentGen END
}

void ifXEntry::update(Request* req)
{
	// This table needs to be updated.

	//--AgentGen BEGIN=ifXEntry::update
	//--AgentGen END
}


//--AgentGen BEGIN=ifXEntry
//--AgentGen END




/**
 *  ifStackEntry
 *
 */

ifStackEntry* ifStackEntry::instance = 0;

const index_info indIfStackEntry[2] = {
	{ sNMP_SYNTAX_INT, FALSE, 1, 1 },
	 { sNMP_SYNTAX_INT, FALSE, 1, 1 } };

const Oidx indOidsIfStackEntry[2] = {
	"1.3.6.1.2.1.31.1.2.1.1",
	"1.3.6.1.2.1.31.1.2.1.2"
};

ifStackEntry::ifStackEntry(const OctetStr& context, SubAgentXMib* mib):
   AgentXSharedTable(oidIfStackEntry, indIfStackEntry, 2, indOidsIfStackEntry, mib, context)
{
	// This table object is a singleton. In order to access it use
	// the static pointer ifStackEntry::instance.
	instance = this;

	add_col(new ifStackStatus(colIfStackStatus));

	//--AgentGen BEGIN=ifStackEntry::ifStackEntry
	//--AgentGen END
}

ifStackEntry::~ifStackEntry()
{

	//--AgentGen BEGIN=ifStackEntry::~ifStackEntry
	//--AgentGen END
}

void ifStackEntry::update(Request* req)
{
	// This table needs to be updated.

	//--AgentGen BEGIN=ifStackEntry::update
	//--AgentGen END
}


//--AgentGen BEGIN=ifStackEntry
//--AgentGen END




/**
 *  ifTestEntry
 *
 */

ifTestEntry* ifTestEntry::instance = 0;

const index_info indIfTestEntry[1] = {
	{ sNMP_SYNTAX_INT, FALSE, 1, 1 } };

const Oidx indOidsIfTestEntry[1] = {
	"1.3.6.1.2.1.2.2.1.1"
};

ifTestEntry::ifTestEntry(const OctetStr& context, SubAgentXMib* mib):
   AgentXSharedTable(oidIfTestEntry, indIfTestEntry, 1, indOidsIfTestEntry, mib, context)
{
	// This table object is a singleton. In order to access it use
	// the static pointer ifTestEntry::instance.
	instance = this;

	add_col(new ifTestId(colIfTestId));
	add_col(new ifTestStatus(colIfTestStatus));
	add_col(new ifTestType(colIfTestType));
	add_col(new MibLeaf(colIfTestResult, READONLY, new SnmpInt32()));
	add_col(new MibLeaf(colIfTestCode, READONLY, new Oid()));
	add_col(new ifTestOwner(colIfTestOwner));

	//--AgentGen BEGIN=ifTestEntry::ifTestEntry
	//--AgentGen END
}

ifTestEntry::~ifTestEntry()
{

	//--AgentGen BEGIN=ifTestEntry::~ifTestEntry
	//--AgentGen END
}

void ifTestEntry::update(Request* req)
{
	// This table needs to be updated.

	//--AgentGen BEGIN=ifTestEntry::update
	//--AgentGen END
}


//--AgentGen BEGIN=ifTestEntry
//--AgentGen END




/**
 *  ifRcvAddressEntry
 *
 */

ifRcvAddressEntry* ifRcvAddressEntry::instance = 0;

const index_info indIfRcvAddressEntry[2] = {
	{ sNMP_SYNTAX_INT, FALSE, 1, 1 },
	 { sNMP_SYNTAX_OCTETS, FALSE, 0, 128 } };

const Oidx indOidsIfRcvAddressEntry[2] = {
	"1.3.6.1.2.1.2.2.1.1",
	"1.3.6.1.2.1.31.1.4.1.1"
};

ifRcvAddressEntry::ifRcvAddressEntry(const OctetStr& context, SubAgentXMib* mib):
   AgentXSharedTable(oidIfRcvAddressEntry, indIfRcvAddressEntry, 2, indOidsIfRcvAddressEntry, mib, context)
{
	// This table object is a singleton. In order to access it use
	// the static pointer ifRcvAddressEntry::instance.
	instance = this;

	add_col(new ifRcvAddressStatus(colIfRcvAddressStatus));
	add_col(new ifRcvAddressType(colIfRcvAddressType));

	//--AgentGen BEGIN=ifRcvAddressEntry::ifRcvAddressEntry
	//--AgentGen END
}

ifRcvAddressEntry::~ifRcvAddressEntry()
{

	//--AgentGen BEGIN=ifRcvAddressEntry::~ifRcvAddressEntry
	//--AgentGen END
}

void ifRcvAddressEntry::update(Request* req)
{
	// This table needs to be updated.

	//--AgentGen BEGIN=ifRcvAddressEntry::update
	//--AgentGen END
}


//--AgentGen BEGIN=ifRcvAddressEntry
//--AgentGen END




if_mib::if_mib(const OctetStr& context, SubAgentXMib* mib):
   MibGroup("1.3.6.1.2.1.2", "ifMIB")
{
	add(new ifNumber());
	add(new ifEntry(context, mib));
	//	add(new ifXEntry(context, mib));
	//	add(new ifStackEntry(context, mib));
	//	add(new ifTestEntry(context, mib));
	//	add(new ifRcvAddressEntry(context, mib));
	//	add(new ifTableLastChange());
	//	add(new ifStackLastChange());
}


//--AgentGen BEGIN=if_mib
//--AgentGen END



//--AgentGen BEGIN=_END
#ifdef AGENTPP_NAMESPACE
}
#endif


